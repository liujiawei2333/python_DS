'''
动态规划

最大子序和（要求是连续自序）
方法一：很巧妙，不好想，复杂度O(n)、
动态规划：先解决子问题，再逐步解决大问题，每个子问题之间有相互关系。
思路：先遍历出以某个节点为结束节点的所有子序列。这是关键，因为常规思维都是以子序列的开头为基准。
解释：
dp[i]：以nums[i]结尾的子序列中最大的和的那个和
例如：dp[3]表示的子序列有：
nums[0]-nums[3]
nums[1]-nums[3]
nums[2]-nums[3]
nums[3]-nums[3]
而dp[3]表示的是这4个子序列中和最大的那个。
求dp[3]：用dp[2]求，dp[2]是以nums[2]结尾的和最大的子序列，所以dp[3]有2个选择，要么nums[3]和dp[2]结合的和更大的子序列，要么变小（dp[2]<0)。
以此类推得到每个位置为结尾的子序列的最大和，最后选出最大的。
'''
def maxSubArray(nums):
    dp=nums[:]
    for i in range(1,len(nums)):
        dp[i]=max(dp[i-1]+nums[i],nums[i])#当前元素自身最大，或者包含之前的后变为最大，即当前索引i永远村存储0~i之间的最大和
    return max(dp)#返回每个索引最大和的最大值

a = [-2,1,-3,4,-1,2,1,-5,4]
b = maxSubArray(a)
print(b)