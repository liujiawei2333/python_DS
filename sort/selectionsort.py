'''
选择排序：
1.长度为n的无序数组中，第一次遍历n-1个数找到最小的和第一个交换；
2.第二次从下一个数遍历n-2个数，找到最小的数和第二个数交换；
3.重复上述操作直到n-1次遍历交换完成，每次找到最小的数放在前面
时间复杂度O(n^2)
虽然时间复杂度与冒泡排序是一样的，但交换元素的次数大大减小（每次遍历只做一次交换），所以比冒泡排序更优
'''
A = [64, 25, 12, 22,22,11] 
  
for i in range(len(A)):
    min_idx = i
    for j in range(i+1, len(A)): 
        if A[min_idx] > A[j]: 
            min_idx = j #寻找本次遍历的最小的元素的索引
                
    A[i], A[min_idx] = A[min_idx], A[i] 
  
print ("排序后的数组：") 
for i in range(len(A)): 
    print("%d" %A[i])

